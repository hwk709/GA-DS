import pandas as pd

# Define the combined function to aggregate by level and generate new features
def aggregate_and_generate_features(df, levels, value_columns, window_size=2):
    """
    Aggregates data by the specified hierarchical levels and generates lagged features, rolling statistics,
    and cumulative statistics for the given value columns.
    
    Args:
    df: Pandas DataFrame containing the dataset.
    levels: List of columns representing the hierarchical levels (e.g., ['L1', 'L2']).
    value_columns: List of columns to aggregate and generate features for (e.g., ['funding', 'requirement']).
    window_size: Rolling window size for rolling statistics.
    
    Returns:
    Aggregated DataFrame with generated features.
    """
    df = df.copy()

    # Step 1: Aggregate by the specified levels and sum the value columns
    aggregated_df = df.groupby(levels)[value_columns].sum().reset_index()

    # Step 2: Ensure the data is sorted by year and the specified levels
    aggregated_df.sort_values(by=['year'] + levels, inplace=True)

    # Step 3: Generate features (lagged values, rolling statistics, cumulative stats)
    for col in value_columns:
        # Lagged features (e.g., requirement from the previous year)
        aggregated_df[f'{col}_lag_1'] = aggregated_df.groupby(levels)[col].shift(1)

        # Rolling average and rolling sum (over window_size years)
        aggregated_df[f'{col}_rolling_mean_{window_size}'] = aggregated_df.groupby(levels)[col].rolling(window=window_size).mean().reset_index(level=levels, drop=True)
        aggregated_df[f'{col}_rolling_sum_{window_size}'] = aggregated_df.groupby(levels)[col].rolling(window=window_size).sum().reset_index(level=levels, drop=True)

        # Cumulative sum and mean
        aggregated_df[f'{col}_cumsum'] = aggregated_df.groupby(levels)[col].cumsum()
        aggregated_df[f'{col}_cummean'] = aggregated_df.groupby(levels)[col].expanding().mean().reset_index(level=levels, drop=True)

        # Ratio of current value to the total at a higher level (e.g., L6 vs L1 total)
        if 'L1' in levels:
            aggregated_df[f'{col}_to_L1_ratio'] = aggregated_df[col] / aggregated_df.groupby(['L1', 'year'])[col].transform('sum')

    # Step 4: Fill NaN values generated by shifts or rolling with 0 (optional)
    aggregated_df.fillna(0, inplace=True)

    return aggregated_df

# Sample dataset with hierarchical levels
data = pd.DataFrame({
    'year': [2020, 2020, 2021, 2021, 2022, 2022, 2023, 2023],
    'L1': ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'B'],
    'L2': ['A1', 'A1', 'A2', 'A2', 'B1', 'B1', 'B2', 'B2'],
    'L3': ['A11', 'A11', 'A21', 'A21', 'B11', 'B11', 'B21', 'B21'],
    'L4': ['A111', 'A111', 'A211', 'A211', 'B111', 'B111', 'B211', 'B211'],
    'L5': ['A1111', 'A1111', 'A2111', 'A2111', 'B1111', 'B1111', 'B2111', 'B2111'],
    'L6': ['A11111', 'A11111', 'A21111', 'A21111', 'B11111', 'B11111', 'B21111', 'B21111'],
    'funding': [1000, 1500, 1100, 1600, 1200, 1300, 1400, 1450],
    'requirement': [1100, 1400, 1200, 1500, 1250, 1350, 1500, 1600]
})

# Apply the combined aggregation and feature generation function at L1 and L2 level
aggregated_and_generated_data = aggregate_and_generate_features(
    df=data,
    levels=['L1', 'L2', 'year'],
    value_columns=['funding', 'requirement'],
    window_size=2
)

# Display the aggregated data with generated features
print(aggregated_and_generated_data)
