import pandas as pd

# Define the function to aggregate data and generate features
def aggregate_and_generate_features(df, groupby_levels, value_column, window_size=2):
    """
    Aggregates the data by the given groupby_levels and generates lagged features, rolling statistics, 
    and cumulative statistics for the value_column.
    
    Args:
    df: Pandas DataFrame containing the dataset.
    groupby_levels: List of levels to group by (e.g., ['year', 'L1', 'L2']).
    value_column: The column to aggregate and generate features for (e.g., 'value').
    window_size: Rolling window size for rolling statistics.
    
    Returns:
    Aggregated DataFrame with generated features.
    """
    # Step 1: Aggregate by the specified levels and sum the value column
    aggregated_df = df.groupby(groupby_levels).agg({value_column: 'sum'}).reset_index()

    # Step 2: Ensure the data is sorted by the groupby_levels
    aggregated_df.sort_values(by=groupby_levels, inplace=True)

    # Step 3: Generate features (lagged values, rolling statistics, cumulative stats)
    
    # Lagged feature (e.g., value from the previous row, respecting the group)
    aggregated_df[f'{value_column}_lag_1'] = aggregated_df.groupby(groupby_levels[:-1])[value_column].shift(1)

    # Rolling mean and rolling sum (over window_size rows)
    aggregated_df[f'{value_column}_rolling_mean_{window_size}'] = aggregated_df.groupby(groupby_levels[:-1])[value_column].rolling(window=window_size).mean().reset_index(level=groupby_levels[:-1], drop=True)
    aggregated_df[f'{value_column}_rolling_sum_{window_size}'] = aggregated_df.groupby(groupby_levels[:-1])[value_column].rolling(window=window_size).sum().reset_index(level=groupby_levels[:-1], drop=True)

    # Cumulative sum and mean
    aggregated_df[f'{value_column}_cumsum'] = aggregated_df.groupby(groupby_levels[:-1])[value_column].cumsum()
    aggregated_df[f'{value_column}_cummean'] = aggregated_df.groupby(groupby_levels[:-1])[value_column].expanding().mean().reset_index(level=groupby_levels[:-1], drop=True)

    # Step 4: Fill NaN values generated by shifts or rolling with 0 (optional)
    aggregated_df.fillna(0, inplace=True)

    return aggregated_df

# Sample dataset with hierarchical levels
data = pd.DataFrame({
    'year': [2020, 2020, 2021, 2021, 2022, 2022, 2023, 2023],
    'L1': ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'B'],
    'L2': ['A1', 'A1', 'A2', 'A2', 'B1', 'B1', 'B2', 'B2'],
    'value': [1000, 1500, 1100, 1600, 1200, 1300, 1400, 1450]
})

# Example usage: Aggregating by year and L1, then generating features
groupby_levels = ['year', 'L1']
result_df = aggregate_and_generate_features(data, groupby_levels, 'value', window_size=2)

# Display the result
print(result_df)
